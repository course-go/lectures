# Fundamentals #1
Course Go
Tags: golang, go

## Outline

TODO

## Go Command

	bug         start a bug report
	build       compile packages and dependencies
	clean       remove object files and cached files
	doc         show documentation for package or symbol
	env         print Go environment information
	fix         update packages to use new APIs
	fmt         gofmt (reformat) package sources
	generate    generate Go files by processing source
	get         add dependencies to current module and install them
	install     compile and install packages and dependencies
	list        list packages or modules
	mod         module maintenance
	work        workspace maintenance
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         report likely mistakes in packages

## Go keywords

    break     case   chan    const       continue
    default   defer  else    fallthrough for
    func      go     goto    if          import
    interface map    package range       return
    select    struct switch  type        var

[GothamGo 2018 - Things in Go I Never Use by Mat Ryer](https://youtu.be/5DVV36uqQ4E?si=hZDbgTxZiUAvAS3g)

## Packages and Imports

- Program building blocks ("libraries")
- Imported by other programs
- Package name is the last element of the import path
- [Standard library packages](https://pkg.go.dev/std)

```
package main
```

## Executable Packages 

- Have to be named `main`
- Have to contain `main()` function as entrypoint

## Hello world

.play assets/lecture-02/hello-world.go

```
$ go build hello.go
$ ./hello
Hello world
```

```
$ go run hello.go
Hello world
```

## Go Format

.play assets/lecture-02/unformatted-hello-world.go

```
go fmt gofmt.go
```

```
package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
```

## Workspace

- Defined by `$GOPATH` variable
    - `$HOME/go` by default
- Structured directory:
    - `/src`: historicaly used for storing source code
        - unused after introduction of go modules
    - `/pkg`: stores downloaded versioned packages
        - `go get`
    - `/bin`: contains executable binaries 
        - `go install`

## Unicode support

- all string literals use UTF-8

.play assets/lecture-02/hello-world-unicode.go

## Types and variables 

## Types

- Similar to C
- No auto casts
- Type inference and default types
- Each type has clear zero value (0, false, "")

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
```

## Variables

.play assets/lecture-02/variables.go

## Constants

.play assets/lecture-02/const.go

## Type conversions

- No auto casts

.play assets/lecture-02/casts.go

## Control Flow

## Conditions

- Similarly to for loop allows init statement
- Variables declared there don't exist outside of the if block

.play assets/lecture-02/if.go

## Else statement

- Variables declared in the init statement do exist in the else block

.play assets/lecture-02/if2.go

## Switch statement

- Again allows init statement
- Like set of if-else statements
- Evaluated top-bottom, first successful case is executed
- Thus there's no break statement

.play assets/lecture-02/switch.go

## Switch statement 2

- Allows non-constant and non-integer values

.play assets/lecture-02/switch2.go

## Switch with no condition

- switch without condition is like switch true

.play assets/lecture-02/switch3.go

## Loops

- Only the `for` keyword exists

.play assets/lecture-02/for.go

## Loops

- break keyword
- continue keyword

## Labels

TODO

## Ignoring return values

- '`_`' idiom can be used to drop return values

.play assets/lecture-02/ignore-return-values.go

## Functions

## Functions

.play assets/lecture-02/functions.go

## Multiple return values

.play assets/lecture-02/functions2.go

## Named return values

.play assets/lecture-02/functions3.go

## Shortening argument type declaration

```
func calculate(x int, y int, z bool) (a int, b int) {
    // ...
}
```

```
func calculate(x, y int, z bool) (a, b int) {
    // ...
}
```

## Lambda functions

- a.k.a. function literals
- https://golang.org/ref/spec#Function_literals
- can be assigned to a variable or invoked directly

## Typical usages for lambda functions

- go blocks
- defer statement
- callback functions
- 'compare' for sorting

## Function as a value (like any other value)

.play assets/lecture-02/01_func_type.go

## Function with parameters as a value (like any other value)

.play assets/lecture-02/02_func_type.go

## Functions stored in local variables (just a toy)

.play assets/lecture-02/03_functions_as_values.go

## Anonymous functions (just a toy again)

.play assets/lecture-02/04_lambdas.go

## Function types

- a new type `BinaryOp` is defined
- it is used to specify parameter type in `applyBinaryOp`

.play assets/lecture-02/05_function_type.go /^package main/,/^func testBinaryOps/

## Function types (cont.)

.play assets/lecture-02/05_function_type.go /^func testBinaryOps/,/^}/

## Closures

- lambda functions that refer to variables defined outside the function
- it "closes over" another function -> the name closure
- code pointer and environment pointer internally
- useful for function that needs to store its state "somewhere"

## Practical example - sorting elements in slice

.play assets/lecture-02/06_sort_function.go /^package main/,/^func main/

## Practical example - sorting elements in slice (cont.)

.play assets/lecture-02/06_sort_function.go /^func main/,/^}/

## Practical example - sorting elements in a slice

- implemented as a closure

.play assets/lecture-02/07_sort_closure.go /^package main/,/^func main/

## Practical example - sorting elements in slice (cont.)

- implemented as a closure

.play assets/lecture-02/07_sort_closure.go /^func main/,/^}/

## Implementation of sort-by

.play assets/lecture-02/08_sort_by.go /^package main/,/^func main/

## Implementation of sort-by (cont.)

.play assets/lecture-02/08_sort_by.go /^func main/,/^}/

## defer statement

- `defer` is a keyword in the Go programming language
- used to "remember" commands that will be called before `return` or exit
- based on LIFO (stack) of remembered commands
- parameters are evaluated when `defer` is declared (ie. in runtime)
- (not when the specified code is called)
- it is possible to change function return value(s) via `defer`

## Basic usage of defer statement

- function `on_finish()` is called before exit from `main()`

.play assets/lecture-02/01_defer_basic_usage.go

## Function declaration in defer statement

- usually the function definition is part of `defer` statement
- this function is anonymous - lambda, and usually it is a closure as well
- (we will talk about lambdas and closures in the next lesson)

.play assets/lecture-02/02_defer_func.go

## Function declaration in defer statement (cont.)

- parenthesis around lambda are not required

.play assets/lecture-02/02B_defer_func.go

## Function declaration with parameters in defer statement

- it is possible to specify arguments passed into function in `defer`

.play assets/lecture-02/03_defer_with_parameters.go

## More defer statements in one function

- ten `defer` statements
- LIFO behaviour
- (check in runtime how it works)

.play assets/lecture-02/04_more_defers.go

## Defer arguments evaluation

- one function can be used in more `defer` statements
- actual parameters are evaluated in runtime
- (check in runtime)

## Defer arguments evaluation (cont.)

.play assets/lecture-02/05_defer_arguments_evaluation.go

## Defer arguments evaluation (more complicated example)

- arrays are a bit tricky
- (call by value vs. call by reference)
- (check in runtime, again)

## Defer arguments evaluation (more complicated example, cont.)

.play assets/lecture-02/06_defer_arguments_evaluation.go

## Defer and (many) return statements

- `defer` is called even when more `return` statements are used

## Defer and (many) return statements

.play assets/lecture-02/07_defer_on_all_returns.go /^package main/,/^func main/

## Defer and (many) return statements (cont.)

.play assets/lecture-02/07_defer_on_all_returns.go /^func main/,/^}/

## Practical usage of defer

- how to use `defer` in an application to copy files

.play assets/lecture-02/08_defer_practical_usage.go /^package main/,/func copyFile/

## Practical usage of defer (cont.)

.play assets/lecture-02/08_defer_practical_usage.go /^func copyFile/,/^}/

## Practical usage of defer (cont.)

.play assets/lecture-02/08_defer_practical_usage.go /^func main/,/^}/

## Practical usage of defer

- previous example refactored

.play assets/lecture-02/09_defer_practical_usage.go /^package main/,/func copyFile/

## Practical usage of defer (cont.)

.play assets/lecture-02/09_defer_practical_usage.go /^func copyFile/,/^}/

## Practical usage of defer (cont.)

.play assets/lecture-02/09_defer_practical_usage.go /^func main/,/^}/

## Defer and return values

- it is possible to change function return value(s) via `defer`
- (works because function declared in defer is closure)
- function return values needs to be named!
- used in applications to set `err` return value

## Defer and return values

.play assets/lecture-02/10_defer_return_values.go

## Pointers

## Pointers

- always points to an element of some type
- ie. `void` pointers are not supported
- implicit pointer value is `nil`
- address of element can be retrieved using the `&` operator
- access via pointer (reference in some other languages) using the `##` operator

## Basic usage of pointers

- please note the usage of `##p_i++`

.play assets/lecture-02/22_pointer_to_int.go

## Pointer to structure

.play assets/lecture-02/23_pointer_to_struct.go /package main/,/func main//

## Pointer to structure (cont.)

- please note the possibility to write `p_u.id` instead of `(##p_u).id`

.play assets/lecture-02/23_pointer_to_struct.go /func main/,/^}//

## Pointer to structure item/member

.play assets/lecture-02/24_pointer_to_struct_item.go /package main/,/func main//

## Pointer to structure item/member (cont.)

.play assets/lecture-02/24_pointer_to_struct_item.go /func main/,/^}//

## Pointer to array item

.play assets/lecture-02/25_pointer_to_array.go /package main/,/cont//

## Pointer to array item (cont.)

.play assets/lecture-02/25_pointer_to_array.go /cont/,/^}//

## Return pointer to local variable from C function

    #include <stdio.h>

    int* get_pointer(void) {
        int i = 42;
        return &i;
    }

    int main(void) {
        int *p = get_pointer();
        printf("%p\n", p);
        printf("%d\n", *p);
        return 0;
    }

## Return pointer to local variable from Go function

.play assets/lecture-02/25_B_return_pointer.go


## Structures

## Structs (records)

- a.k.a. records
- user-defined data type (so called named structure)
- or anonymous structure
- dot operator to access struct members
- initialization using {}
- or by using named members (which is more explicit and better)
- structs are comparable
- it is possible to print whole struct
- pass to functions as value or via pointer (by reference)

## Structs and dot operator

.play assets/lecture-02/11_struct.go

## Initialization of struct members

- similar to C language initialization
- usage of {} parenthesis
- C-like initialization: order matters!

## Initialization of struct members (cont.)

.play assets/lecture-02/12_struct_init.go

## Better (more explicit) initialization of struct members

- struct members are explicitly specified by name
- better readability 
- preferred approach

## Better (more explicit) initialization of struct members (cont.)

.play assets/lecture-02/13_better_struct_init.go

## Comparison of whole structs is possible!

- `==` and `!=` operators
.play assets/lecture-02/14_struct_comparison.go /^func main/,/^}/

## Comparison of whole structs is possible! (cont.)

.play assets/lecture-02/14_struct_comparison.go /^func main/,/^}/

## Passing structs as values into functions

- by value
- by reference (via pointer)

.play assets/lecture-02/15_print_user.go /package main/,/^func main//

## Passing structs as values into functions (cont.)

.play assets/lecture-02/15_print_user.go /^func main/,/^}/

## Struct embedding

.play assets/lecture-02/40_struct_embedding.go

## Anonymous structure

- just declare new variable and specify its type to `struct` _something_

    var employee struct {  
            firstName, lastName string
            age int
    }

## Methods on types

- a _method_ is a function that has a defined receiver
- (in OOP: a method is a function on an instance of an object)
- concept of a _receiver_
- usage - method declaration

    func (receiver) method_name(parameters) return_types {
        ...
        ...
        ...
    }

- method is called by

    some_object.method_name(parameters)

- methods can modify (mutate) a receiver
- call by value vs. call by reference (via pointer)

## User type with one method

.play assets/lecture-02/09_methods.go

## Receiver used as a value

.play assets/lecture-02/10_methods_with_parameters.go

## Receiver used via pointer

.play assets/lecture-02/11_methods_ptr.go

## Nil receiver

.play assets/lecture-02/21_nil_receiver.go

## More methods for the same type

.play assets/lecture-02/12_more_methods.go /// Line/,/End OMIT/

