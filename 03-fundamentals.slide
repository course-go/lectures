# Fundamentals #2
Course Go
Tags: golang, go

## Outline

TODO

## Keywords

    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var

## Operators and characters with special meaning

    +    &     +=    &=     &&    ==    !=    (    )
    -    |     -=    |=     ||    <     <=    [    ]
    ##    ^     ##=    ^=     <-    >     >=    {    }
    /    <<    /=    <<=    ++    =     :=    ,    ;
    %    >>    %=    >>=    --    !     ...   .    :
         &^          &^=

## Interfaces

## Interfaces

- set of methods required to implement such interface
- declared via `interface` keyword:

    type XI interface {
        method1()
        method2(int) int
    }

- interface type — variable of interface type, can hold any value implementing an interface
- variable of interface type ##I## can hold any value _implementing_ ##I##

## Implementing an interface

- a.k.a. _satisfying_ an interface
- no such keyword (`implements` or anything similar)
- in Go: every type which implements all interface’s method automatically satisfies such interface

## How to satisfy an interface

- artifical example

.play assets/lecture-03/13_B_satisfy.go

## Embedding other interface(s)

- embedding other interfaces is possible

    type XII interface {
        m2()
        XI
    }

- order does not matter there

## Circular embedding

- forbidden, detected by compiler

    type I1 interface {
        I2
        method_i1()
    }
    
    type I2 interface {
        I3
        method_i2()
    }
    
    type I3 interface {
        I1
        method_i3()
    }

## Declaration of two interfaces

.play assets/lecture-03/13_interface.go

## Missing interface implementation

.play assets/lecture-03/14_interface_missing_implementation.go /^package main/,/^func main/

## Missing interface implementation (cont.)

.play assets/lecture-03/14_interface_missing_implementation.go /^func main/,/^}/

## Implementation of an interface

.play assets/lecture-03/15_interface_implementation_via_methods.go /^package main/,/^func main/

## Implementation of an interface (cont.)

.play assets/lecture-03/15_interface_implementation_via_methods.go /^func main/,/^}/

## More implementations of one interface (1/5)

- the longest example :)

.play assets/lecture-03/16_more_interface_implementations.go /^package main/,/^type Line/

## More implementations of one interface (2/5)

.play assets/lecture-03/16_more_interface_implementations.go /^type Line/,/^func/

## More implementations of one interface (3/5)

.play assets/lecture-03/16_more_interface_implementations.go /^func \(line/,/^func main/

## More implementations of one interface (4/5)

.play assets/lecture-03/16_more_interface_implementations.go /^func main/,/cont/

## More implementations of one interface (5/5)

.play assets/lecture-03/16_more_interface_implementations.go /cont/,/^}/

## Empty interface

- is automatically satisfied by any type
- value of any type can be assigned to such interface type variable

.play assets/lecture-03/17_empty_interface.go

## Type `any`

- basically

    type any interface{}

- used in standard library at many places

## `nil` interface

- Interface type value consists of two components: dynamic type and dynamic value
- ##static## ##type##: known by compiler, from the declaration
- ##dynamic## ##type##: type of assigned _value_
- ##dynamic## ##value##: the actual value assigned
- where's the problem?
- interface type value is `nil` if both dynamic value ##and## dynamic type are `nil`
- sometimes we get the impression that `nil`!=`nil`

## `nil` interface

.play assets/lecture-03/18_nil_interface_riddle.go

## `nil` interface

.play assets/lecture-03/20_three_nil_interfaces.go

## Type assertions

- access to an interface value's underlying concrete value

    variable := iface.(Type)

- two operations:
- check that the interface value `iface` holds the concrete type `Type` (with panicking)
- assign the underlying `Type` value to the variable `variable`.

    variable, ok := iface.(Type)

- check that the interface value `iface` holds the concrete type `Type`
- if check failed, `variable` will contain zero value and `ok` will be `false`
- if check passed, assign the underlying `Type` value to the variable `variable`, `ok` will be `true`

## Type assertions

.play assets/lecture-03/19_type_assertions.go

## Type assertions

.play assets/lecture-03/handle_server_error.go

## Errors

## Error 

- error is a built-in type

```
type error interface {
    Error() string
}
```

## Error handling

[Go Blog: Error handling and Go](https://go.dev/blog/error-handling-and-go)

.play assets/lecture-03/ret.go

## Line of sight

- About idiomatic and easy to comprehend Go code
- [[https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88]]
- "Happy path" on the left (one column)
- No nest of indented braces for "happy path"
- Exit early
- No else returns style statements (`golint` is able to detect it)
- "Happy return" at the very last line

## Panic

.play assets/lecture-03/panic.go

## Recover

TODO

## Arrays

- basic data type in the Go programming language
- all array items has the same type
- (well, you can use `interface{}` to allow _dynamic_typing_behaviour_)
- type of array is derived from type of items ##and## array size
- (unlike slices)
- index in range 0..length-1
- items indexing via [] (as in most other languages)

## Basic operations with arrays

.play assets/lecture-03/16_arrays.go

## Matrix (two dimensional array)

.play assets/lecture-03/16B_arrays.go

## Array copy

- unlike slices, arrays can be copied
.play assets/lecture-03/17_array_copy.go

## Slices

- proper data type in the Go programming language
- interface to sequences (better than arrays)
- slices are used more often than _plain_ _old_ _arrays_
- type of slice is derived from type of items
- slices has defined length and capacity (those numbers can be different)
- internaly a slice is triple: (pointer to the first element + `len` + `cap`)
- so called "slice operator" `[from:to]`
- `append` function to add a new element to slice (complicated internally)

## Usage of slices

.play assets/lecture-03/18_slices.go /package main/,/cont//

## Usage of slices (cont.)

.play assets/lecture-03/18_slices.go /cont/,/^}//

## Slices and arrays as data source for them

- slice can be created from any array
- but the slice does not contain any data, just a pointer to array element
- so any modify in slice element is reflected in an array as well

.play assets/lecture-03/19_slice_copy.go /package main/,/cont//

## Slices and arrays as data source for them (cont.)

- modify array elements
- then modify the same elements, but via slice

.play assets/lecture-03/19_slice_copy.go /cont/,/^}//

## Slice from slice

- "slicing" of another slice is possible
.play assets/lecture-03/20_slice_from_slice.go /package main/,/cont//

## Slice from slice (cont.)

.play assets/lecture-03/20_slice_from_slice.go /cont/,/^}//

## Append function

- the function `append` returns a new slice
- the capacity of new slice can be increased (realloc magic inside!)
.play assets/lecture-03/21_slice_append.go

## Maps

- a.k.a. associative array or hash
- container for key-value pairs
- "nil map":

    var m1 map[int]string

- empty map:

    var m2 map[int]string = make(map[int]string)
    m3 := make(map[int]string)

## Maps

- three basic operations: add/put, get, and delete
- add/put items to a map:

    m3[0] = "zero"
    m3[1] = "one"
    m3[2] = "two"

- get item from a map:

    m3[2]

- delete from a map

    delete(m3, 0)

## Unitialized map ("nil map")

.play assets/lecture-03/26_uninitialized_map.go

## Unitialized map ("nil map")

.play assets/lecture-03/26_B_uninitialized_map.go

## Empty map (int -> string)

.play assets/lecture-03/27_initialized_map.go

## Empty map (string -> int)

.play assets/lecture-03/27_B_initialized_map.go

## Empty map (shorter idiom)

.play assets/lecture-03/28_initialized_map.go

## Maps and struct

.play assets/lecture-03/29_map_and_struct.go /^package main/,/^func main/

## Maps and struct (cont.)

.play assets/lecture-03/29_map_and_struct.go /^func main/,/^}/

## Struct can be used as key as well

.play assets/lecture-03/30_map_and_struct_B.go /^package main/,/^func main/

## Struct can be used as key as well (cont.)

.play assets/lecture-03/30_map_and_struct_B.go /^func main/,/^}/

## Reading items from map

.play assets/lecture-03/31_reading_from_maps.go /^package main/,/cont/

## Nonexistent values

.play assets/lecture-03/31_map_nonexistent_values.go

## Reading items from map (cont.)

.play assets/lecture-03/31_reading_from_maps.go /cont/,/^}/

## Deleting items from map

.play assets/lecture-03/32_delete_from_map.go /^package main/,/^func main/

## Deleting items from map (cont.)

.play assets/lecture-03/32_delete_from_map.go /^func main/,/^}/

## Sets

- is is possible to simulate them using maps

  map[key_type]struct{}

## Loops and the range clause

- (see the 1st lesson for a `for` loop examples)
- `range` keyword used in `for` to loop over array items, map pairs etc.
- provides an item index as well (Java on the other side...)

## Iterating over an array

.play assets/lecture-03/33_for_range_1.go

## Index can be ignored

.play assets/lecture-03/34_for_range_2.go

## Iterating over slice

.play assets/lecture-03/35_for_range_3.go

## Iterating over Unicode glyphs

.play assets/lecture-03/36_for_range_4.go

## Iterating over map pairs (key+value)

.play assets/lecture-03/37_for_range_map.go

## User-defined data types

- `type` keyword
- Go is very strict in typing (see examples)

## User-defined data types

.play assets/lecture-03/38_user_types.go

## User-defined data types (passing to function)

.play assets/lecture-03/39_type_func_params.go

## Generics

TODO

## Standard library

TODO
